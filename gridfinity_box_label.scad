//------------------------------------------------------
/* [General customization] */

//Label size
Y_units = 5; // [4,5,7,8]

//Show Devider line
Show_Devider = true;

// Choose logo type: emoji, character, or hardware icons
LOGO_TYPE = "char"; // ["emoji", "char", "hardware"]




/* [Emoji settings] */
LOGO_EMOJI = "🌐"; //[😂,💻, ❤️,😍,🤣,😊,🥺,🙏,💕,😭,😘,👍,😅,👏,🥰,💀,✌️,😬,👀,😏,😒,😳,😜,😎,😇,🐵,🐶,🐺,🦊,🐱,🦁,🐯,🐴,🦄,🐮,🐷,🐭,🐹,🐰,🦓,🐻,🐼,🦘,🦡,🐨,🐔,🐦,🐤,🦉,🌴,🌵,🌷,🌻,🌼,🍂,🍁,🌾,🌱,🍄,🌲,🌳,🌿,☘️,🍀,🌹,🌺,🌸,🌞,🌝,🌛,🌜,🌚,🌕,🍏,🍎,🍐,🍊,🍋,🍌,🍉,🍇,🍓,🍈,🍒,🍑,🍍,🥭,🥥,🥝,🍅,🥑,🍆,🥒,🥬,🌶️,🌽,🥕,🍰,🎂,🧁,🍦,🍧,🍨,🍩,🍪,🍫,🍬,🍭,🍮,🍯,🍼,🥛,🍵,🍶,🍾,🍷,🍸,🍹,🍺,🍻,🥂,⚽,🏀,🏈,⚾,🎾,🏐,🏉,🎱,🏓,🏸,🥅,🏒,🏑,🏏,🥊,🥋,🎿,⛷,🏂,🏋️‍♂️,🤸‍♀️,⛹️‍♂️,🤾‍♀️,🏌️‍♂️,🚗,🚕,🚙,🚌,🚎,🏎,🚓,🚑,🚒,🚐,🛴,🚲,🛵,🏍,🚨,🚔,🚍,🚘,🚖,🚡,🚠,🚟,🚃,🚞,🏡,🏘,🏠,🏚,🏢,🏬,🏣,🏤,🏥,🏦,🏨,🏪,🏫,🏩,🏛,🏺,🕌,🕍,🕋,⛪,🛤,🛣,🗽,🏰,🎁,🎀,🎊,🎉,🎈,🎂,🎌,🎏,🎄,🎅,🤶,🦌,🧧,🎎,🏮,🎐,🧨,🎇,🎆,🎋,🎍,🎠,🎡,🎢,👓,🕶,🥽,🥼,🌂,🧵,🧶,👔,👕,👖,🧣,🧤,🧥,🧦,👗,👘,👙,👚,👛,👜,👝,🎒,👞,👟,🧿,🔮,💡,🔦,🏮,📽,🎬,📸,📹,🎥,🎞,📺,📻,🎙,🎚,🎛,🧭,🧱,🔨,🛠,🗡,⚔️,🔪,🏹,🎵,🎶,📯,🎤,🎧,🎷,🎸,🎹,🎻,🎺,🥁,🪘,📣,📢,👾,🎮,🕹,🎰,🖨,🖱,🖲,💾,💿,📀,🚀,🛸,🛰,🛳,🚢,🚤,🛶,⛴,🛥,🚜,🚛,🚚,🚒,🚑,🚓,🚍,🚔,🚘,🚖,🚡,🚠,🚟,🚃,🚞,💯,✅,❌,⭕,🔝,🔜,🔚,🔙,🔛,🔱,🔆,🔅,📛,🔰,💤,🚷,🚯,🚳,🚱,🔞,📵,🚭,❗,❓,🕊️,🦜,🦢,🦉,🦚,🦜,🦩,🦚,🦤,🦉,🐉,🐲,🦕,🦖,🐍,🦎,🦗,🐜,🦟,🦠,🕷,🕸,🐚,🦞,🌌,🪐,⭐,🌟,🌠,🌜,🌛,🌚,🌕,🌖,🌗,🌘,🌑,🌒,🌓,🌔,🌙,🌎,🌍,🌏,🌐,🗺,🧭,🏞,🍟,🍔,🌭,🍕,🍖,🍗,🥩,🥓,🥚,🥯,🍞,🥖,🥨,🧀,🥞,🧇,🥓,🍳,🥚,🍳,🍜,🍲,🍛,🍣,🧸,🪀,🪁,🪂,🪃,🏹,🪆,🎭,🎨,🧵,🧶,🎯,🎮,🎲,🎳,🎴,🎠,🎡,🎢,🎪,🤹,🪄,🎭,🎨,🤖,👽,👻,💩,👺,👹,👾,🎃,👼,🤡,🧙,🧛,🧟,🧞,🧜,🧚,🧝,🧙‍♂️,🧙‍♀️,🧚‍♂️,🧚‍♀️,🧛‍♂️,🧛‍♀️,🧜‍♂️,🧜‍♀️]

/* [Character settings ] */
LOGO_CHAR = "M3";
LOGO_SIZE = 12; //[8:16]
LOGO_ROTATION = 0; //[0:90]


/* [Hardware settings ] */
Hardware_type = "Socket head bolt"; // [Socket head bolt, Hex head bolt, Dome head bolt, Countersunk socket head bolt, Standard washer, Spring washer, Standard nut]



/* [Text customization] */
Line_1_text = "Bolts";
Line_2_text = "Nuts";
Line_3_text = "Washers";
Line_4_text = "Inserts";


//Flush text requires an AMS
text_type = "Raised Text"; // [Raised Text, Flush Text]


//Font type
text_font = "Noto Sans SC:Noto Sans China"; // [HarmonyOS Sans, Inter, Inter Tight, Lora, Merriweather Sans, Montserrat, Noto Sans, Noto Sans SC:Noto Sans China, Noto Sans KR, Noto Emoji, Nunito, Nunito Sans, Open Sans, Open Sans Condensed, Oswald, Playfair Display, Plus Jakarta Sans, Raleway, Roboto, Roboto Condensed, Roboto Flex, Roboto Mono, Roboto Serif, Roboto Slab, Rubik, Source Sans 3, Ubuntu Sans, Ubuntu Sans Mono, Work Sans]

//Font Style
Font_Style = "Bold"; // [Regular,Black,Bold,ExtraBol,ExtraLight,Light,Medium,SemiBold,Thin,Italic,Black Italic,Bold Italic,ExtraBold Italic,ExtraLight Italic,Light Italic,Medium Italic,SemiBold Italic,Thin Italic]

//Font size
text_size = 4.2;

// Set a margin factor (adjustable)
margin_factor = 0.15; // 15% margin on top and bottom



/* [Additional settings] */
width=24.5;
height=0.85;
radius= 3.5;
champfer=0.2;
$fs = 0.1;
$fa = 5;

/* [Hidden] */
text_height = (text_type == "Raised Text") ? 0.2 : 0.02;
Font = str(text_font, ":style=", Font_Style);


length = getDimensions(Y_units);  // Set length based on Y_units value
z_max = height + text_height;

translate([- (length / 2), - (width / 2), 0])


label(
    length = length, 
    width = width, 
    height = height,
    radius = radius,

    champfer = champfer
);





// Corrected function for setting length based on Y_units
function getDimensions(Y_units) =
    (Y_units == 4) ? 25.5 :
    (Y_units == 5) ? 67.5 :
    (Y_units == 7) ? 82 :
    (Y_units == 8) ? 100 : 0; // Default value if no match


module label(length, width, height, radius,  champfer)
{   
    color("black") {  
        difference() {
            __shapeWithChampfer(
                length, 
                width, 
                height, 
                radius, 
                champfer
            );     
        }
    }
    
    color("white") { 
        render_logo();
        
    if (Y_units > 4){
        //translate([((length / 2) + width / 2), width * (2 / 5), 0]) 
        render_text();
    }
        
    }
}




module render_text() {
    // Array of text lines
    lines = [Line_1_text, Line_2_text, Line_3_text, Line_4_text];

    // Filter out empty lines
    non_empty_lines = [for (line = lines) if (line != "") line];

    // Number of non-empty lines
    num_lines = len(non_empty_lines);
    echo("Total non-empty lines:", num_lines);

    if (num_lines > 0) {
        // Define the total height available for text
        effective_height = width * (1 - 2 * margin_factor);
        margin_spacing = width * margin_factor;

        // Handle line spacing
        line_spacing = (num_lines > 1)
        ? effective_height / (num_lines - 1) // For multiple lines
        : 0; // Single line, no spacing

        // Render each line of text
        linear_extrude(z_max) {
        for (i = [0 : num_lines - 1]) {
            y_position = (num_lines == 1)
            ? width / 2 // Center vertically for single line
            : width - margin_spacing - (line_spacing * i); // Spread lines evenly

            translate([
            length / 2 + width / 2, // Center horizontally
            y_position, // Dynamic vertical positioning
            0 // Z-position
            ])
            text(non_empty_lines[i], size=text_size, font=Font, halign="center", valign="center");
            }
        }
    }
}

module render_logo( logo_name) {  

    if (LOGO_TYPE == "emoji"){
        render_emoji(LOGO_EMOJI);
    }

    if (LOGO_TYPE == "char"){
        render_char(LOGO_CHAR);
    }
    if (LOGO_TYPE == "hardware"){
        render_hardware(Hardware_type);
    }
    
     if (Show_Devider && Y_units > 4){  
        // Render the divider line next to the logo
        translate([width, width / 2 - (width * 0.8) / 2, 0])
        cube([1, width * 0.8, z_max]);
     }




}


module render_emoji(LOGO) {
    linear_extrude(z_max)
    
       color("red")
       translate([(width/2), width / 2, 0])
       rotate([0,0,LOGO_ROTATION])
       rotate([0,0,0])
       text(LOGO, font="Noto Emoji:style=Bold", size=LOGO_SIZE, halign="center", valign="center");
}

module render_char(LOGO) {
    linear_extrude(z_max)
       translate([(width/2), width / 2, 0])
       rotate([0,0,LOGO_ROTATION])
       rotate([0,0,-0])
       text(LOGO,  size=LOGO_SIZE, halign="center", valign="center");

}


//module render_hardware(Hardware_type) {
//    linear_extrude(z_max)
//    
//       color("red")
//       translate([(width/2), width / 2, 0])
//       rotate([0,0,LOGO_ROTATION])
//       rotate([0,0,0])
//       text(LOGO, font="Noto Emoji:style=Bold", size=LOGO_SIZE, halign="center", valign="center");
//}


// Function to select the appropriate bolt head module
module render_hardware(Part_version, bolt_length = 8, width = width, height = height) {
    
    translate([width/2, 0, 0])
    
    if (Part_version == "Socket head bolt") {
        Socket_head(bolt_length, width, height);  
    } else if (Part_version == "Hex head bolt") {
        Hex_head(bolt_length, width, height);
    } else if (Part_version == "Countersunk socket head bolt") {
        Countersunk_socket_head(bolt_length, width, height);
    } else if (Part_version == "Dome head bolt") {
        Dome_head(bolt_length, width, height);
    } else if (Part_version == "Standard washer") {
        standard_washer(width, height); 
    } else if (Part_version == "Spring washer") {
        spring_washer(width, height);
    } else if (Part_version == "Standard nut") {
        standard_Nut(width, height);
    }
}



// Hardware icons generators --------------------------

module standard_Nut(width, height, vertical_offset = width/2) {    
    // Center the icon
    translate([-4, vertical_offset, height]) {        
    // Top view of the bolt head
    difference() {    
        cylinder(h=text_height, d=11, $fn=6); 
        cylinder(h=text_height, d=6);
    }
    
    translate([7, -5, 0])
    cube([5.6, 10, text_height]);

    }
}


module standard_washer(width, height, vertical_offset = width/2) {    
    // Center the icon
    translate([-2.5, vertical_offset, height]) {        
    // Top view of the bolt head
    difference() {    
        cylinder(h=text_height, d=10); 
        cylinder(h=text_height, d=6);
    }
    
    translate([7, -5, 0])
    cube([2, 10, text_height]);

    }
}

module spring_washer(width, height, vertical_offset = width/2) {    
    // Center the icon
    translate([-1.5, vertical_offset, height]) {      
    // Top view of the bolt head
    difference() {    
        cylinder(h=text_height, d=10); 
        cylinder(h=text_height, d=6);
        cube([5, 1.6, text_height]);
    }
    
    translate([7, -5, 0])
    cube([2, 10, text_height]);

    }
}



// Bolt icons modules  ------------------------------------------------------

module Socket_head(bolt_length, width, height, vertical_offset = width/2) {
    
    // Set the display length to 20 if bolt_length exceeds 20
    display_length = (bolt_length > 20) ? 20 : bolt_length;

    // Center the entire icon horizontally based on display_length
    translate([-display_length / 2 - 2, vertical_offset, height]) {
        
        // Top view of the bolt head
        difference() {    
            cylinder(h=text_height, d=5); 
            cylinder(h=text_height, r=1.6, $fn=6);
        }
        
        // Side view of the bolt head
        translate([3, -2.5, 0])
        cube([4, 5, text_height]);
        
        // Side view of the bolt stem, with a gap if bolt_length > 20
        if (bolt_length > 20) {
            // Cap the visible length at 20 units and add a gap in the middle
            translate([7, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // First half (10 units)

            translate([7 + 12, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // Second half (10 units)
            
            
        } else {
            // Regular full-length stem if bolt_length <= 20
            translate([7, -1.25, 0])  
            cube([bolt_length, 2.5, text_height]);
        }
    }
}

module Hex_head(bolt_length, width, height, vertical_offset = width/2) {
    
    // Set the display length to 20 if bolt_length exceeds 20
    display_length = (bolt_length > 20) ? 20 : bolt_length;

    // Center the entire icon horizontally based on display_length
    translate([-display_length / 2 - 2, vertical_offset, height]) {
        
        // Top view of the bolt head         
        cylinder(h=text_height, d=5, $fn=6);      
        
        // Side view of the bolt head
        translate([3, -2.5, 0])
        cube([3, 5, text_height]);
        
        // Side view of the bolt stem, with a gap if bolt_length > 20
        if (bolt_length > 20) {
            // Cap the visible length at 20 units and add a gap in the middle
            translate([6, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // First half (10 units)

            translate([6 + 12, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // Second half (10 units)
            
            
        } else {
            // Regular full-length stem if bolt_length <= 20
            translate([6, -1.25, 0])  
            cube([bolt_length, 2.5, text_height]);
        }
    }
}



module Countersunk_socket_head(bolt_length, width, height, vertical_offset = width/2) {
    
    // Set the display length to 20 if bolt_length exceeds 20
    display_length = (bolt_length > 20) ? 20 : bolt_length;

    // Center the entire icon horizontally based on display_length
    translate([-display_length / 2 - 2, vertical_offset, height]) {
        
        // Top view of the bolt head
        difference() {    
            cylinder(h=text_height, d=5); 
            cylinder(h=text_height, r=1.6, $fn=6);
        }
        
        // Side view of the bolt head
        translate([5, 0, 0])
        //triangle
        cylinder(r=3, h=text_height, $fn=3);
        
        // Side view of the bolt stem, with a gap if bolt_length > 20
        if (bolt_length > 20) {
            // Cap the visible length at 20 units and add a gap in the middle
            translate([5, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // First half (10 units)

            translate([5 + 12, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // Second half (10 units)
            
            
        } else {
            // Regular full-length stem if bolt_length <= 20
            translate([5, -1.25, 0])  
            cube([bolt_length, 2.5, text_height]);
        }
    }
}


module Dome_head(bolt_length, width, height, vertical_offset = width/2) {
    
    // Set the display length to 20 if bolt_length exceeds 20
    display_length = (bolt_length > 20) ? 20 : bolt_length;

    // Center the entire icon horizontally based on display_length
    translate([-display_length / 2 - 2, vertical_offset, height]) {
        
        // Top view of the bolt head
        difference() {    
            cylinder(h=text_height, d=5); 
            cylinder(h=text_height, r=1.6, $fn=6);
        }
        
        // Side view of the bolt head
        translate([6, 0, 0])
        
        difference() {
            cylinder(h=text_height, d=5);
            translate([0, -2.5, 0])
            cube([4, 5, text_height]);
        }
        
        
        
        // Side view of the bolt stem, with a gap if bolt_length > 20
        if (bolt_length > 20) {
            // Cap the visible length at 20 units and add a gap in the middle
            translate([6, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // First half (10 units)

            translate([6 + 12, -1.25, 0])  
            cube([8.5, 2.5, text_height]);  // Second half (10 units)
            
            
        } else {
            // Regular full-length stem if bolt_length <= 20
            translate([6, -1.25, 0])  
            cube([bolt_length, 2.5, text_height]);
        }
    }
}



// Shape designer functions --------------------------

module __shapeWithChampfer(
    length=160,
    width=120,
    height=40,
    radius=10,
    champfer=4
)
{
    // Apply chamfer at the bottom
    translate([0, 0, 0])
    __champfer(length, width, champfer, radius, flip=false); 
    
    // Apply the main shape, reduced in height to account for both chamfers
    translate([0, 0, champfer])
    __shape(length, width, height - 2 * champfer, radius);

    // Apply chamfer at the top
    translate([0, 0, height - champfer])
    __champfer(length, width, champfer, radius, flip=true); 
}


module __shapeWithFillet(
    length=160,
    width=120,
    height=40,
    radius=10,
    fillet=4,
    flip=false
)
{
    fillet_size = min(fillet, radius / 2);
    start1 = (flip == true) ? height - fillet_size : 0;
    start2 = (flip == true) ? 0 : fillet_size;
    hull() {
        translate([0, 0, start1])
        __fillet(length, width, fillet_size, radius, flip); 
        translate([0, 0, start2])
        __shape(length, width, height - champfer, radius);
    }
}

module __fillet (
    length=160,
    width=120,
    size=4,
    radius=10,
    flip=false
) {
    start_fillet = (flip == true) ? 0 : size;
    start_cutout = (flip == true) ? - size - 1: size;

    difference() {
        translate([0,0,start_fillet])
        hull () {
            rotate(180)
            translate ([- radius, - radius, 0])
            rotate_extrude(angle = 90)
            translate([radius - size, 0, 0])
            circle(r = size, $fn = 100);

            rotate(90)
            translate ([width - radius, - radius, 0])
            rotate_extrude(angle = 90)
            translate([radius - size, 0, 0])
            circle(r = size, $fn = 100);

            rotate(0)
            translate ([length - radius, width - radius, 0])
            rotate_extrude(angle = 90)
            translate([radius - size, 0, 0])
            circle(r = size, $fn = 100);

            rotate(270)
            translate ([- radius, length - radius, 0])
            rotate_extrude(angle = 90)
            translate([radius - size, 0, 0])
            circle(r = size, $fn = 100);
        }

        translate([0,0,start_cutout])
        hull() {
            translate ([radius, radius, 0]) cylinder (h = size + 1, r=radius);
            translate ([radius, width-radius, 0]) cylinder (h = size + 1, r=radius);
            translate ([length-radius,width-radius, 0]) cylinder (h = size + 1, r=radius);
            translate ([length-radius, radius, 0]) cylinder (h = size + 1, r=radius);
        }
    }
}

module __champfer (
    length=160,
    width=120,
    size=4,
    radius=10,
    flip=false
) {
    r1 = (flip == true) ? radius : radius - size;
    r2 = (flip == true) ? radius - size : radius;
    hull() {
        translate ([radius, radius, 0]) cylinder (h = size, r1=r1, r2=r2);
        translate ([radius, width-radius, 0]) cylinder (h = size, r1=r1, r2=r2);
        translate ([length-radius,width-radius, 0]) cylinder (h = size, r1=r1, r2=r2);
        translate ([length-radius, radius, 0]) cylinder (h = size, r1=r1, r2=r2);
    }
}

module __shape(
    length=160,
    width=120,
    height=40,
    radius=10,
){
    hull() {
        translate ([radius, radius, 0]) cylinder (h = height, r=radius);
        translate ([radius, width-radius, 0]) cylinder (h = height, r=radius);
        translate ([length-radius,width-radius, 0]) cylinder (h = height, r=radius);
        translate ([length-radius, radius, 0]) cylinder (h = height, r=radius);
    }
}
